### 架構設計

### 前端 (Frontend)

#### 1. 微前端架構 (Micro-Frontend Architecture)

為了滿足前後端分離、支援微前端、並整合 Vue 3.x，以下是目前業界最主流的微前端框架：

##### Single-SPA

- **描述**: 一個強大的 JavaScript 路由器，可將多個獨立的單頁應用程式（SPA）整合在一個頁面中。它是最成熟、社群最活躍的微前端框架之一，能夠完美支援 Vue 3.x。
- **優勢**: 框架無關性（Framework Agnostic），可以混合使用任何前端框架。它提供了一套完整的生命週期管理機制（bootstrap, mount, unmount），讓主應用（Root Config）能精準控制各個子應用。
- **整合策略**: 建立一個主應用程式（Root Application 或稱 Container），負責路由和渲染公共組件（如 Header、Footer）。Vue 3.x 的子專案則作為獨立的子應用（Micro-application）被主應用懶加載（Lazy Load）。

##### Module Federation (Webpack 5)

- **描述**: Webpack 5 內建的強大功能，允許一個 JavaScript 應用在運行時動態加載另一個應用的程式碼。這使得不同專案之間可以輕鬆共享模組（如元件、函式庫）。
- **優勢**: 更底層、更靈活的整合方式。它可以實現真正的「依賴共享」，避免多個子應用重複加載相同的函式庫（如 Vue 核心），從而優化整體性能。
- **整合策略**: 將 Vue 3.x 子專案設定為 remote，並將主應用設定為 host。主應用可以動態地從子應用中引入（import）所需的元件或整個應用程式。

- 採前後分離
- 前端與後端透過Restful API, 需滿足open API 3.X 最新版 規格
   - 標準化描述 API：透過一致的格式，讓 API 文件更具可讀性與可維護性。
   - 自動生成文件：可自動產生互動式 API 文件（如 Swagger UI），提升開發效率。
   - 支援 SDK 生成：根據 OpenAPI 描述檔，可自動產生多種語言的用戶端程式碼。
   - 便於測試與模擬：可快速建立 API 測試環境，模擬請求與回應。
   - 強化安全性與版本管理：可清楚定義 API 的授權機制與版本控制策略。


#### 2. CSS 與開發語言

##### CSS 框架: Tailwind CSS

- **描述**: 一個功能優先（Utility-First）的 CSS 框架，提供大量預設的 CSS class，讓開發者可以直接在 HTML 中快速建構 UI，而無需編寫大量的自定義 CSS。
- **優勢**: 開發速度快、高度可客製化、容易實現 RWD，且能有效約束樣式，避免 CSS 污染。

##### 開發語言: TypeScript

- **描述**: JavaScript 的一個超集，增加了靜態型別系統。
- **優勢**: 提供了強型別檢查，能在編譯時期發現潛在錯誤，提升程式碼的健壯性和可維護性，並改善了大型專案中的開發體驗。

#### 通用功能與設定

**Log (日誌):**

- **技術**: Sentry, LogRocket, Datadog
- **描述**: 這些服務不僅能記錄前端的錯誤日誌（Exceptions），還能追蹤使用者的操作流程和網路請求，幫助快速定位問題。

**Exception (異常處理):**

- **技術**: 在框架層級（Vue）建立全域的錯誤處理機制 (Global Error Handler)，並整合上述 Log 工具進行上報。

**多語系 (i18n):**

- **Vue 3.x**: vue-i18n (最新版本)
- **Angular**: @ngx-translate/core
- **實踐**: 將語言檔案（如 JSON）統一管理，並透過上述函式庫實現動態切換。

**監控 (Monitoring):**

- **技術**: Prometheus + Grafana (前端可透過 prometheus-js-client) 或使用 Datadog, New Relic 等商業解決方案。
- **監控指標**: 頁面載入時間 (LCP, FCP)、互動延遲 (FID)、API 請求成功率與耗時等。

##### 統一設定檔

- **實踐**: 在主應用中建立一個統一的設定檔（例如 config.json 或 environment.ts），並在建置流程中根據不同環境（開發、測試、生產）注入對應的設定值。子應用透過 props 或約定的 API 從主應用獲取設定，確保所有子系統的設定來源單一。

#### 3. SPA, RWD 與 UI/UX 規則

##### SPA (Single-Page Application)

Vue 3.x 和 Angular 都是專為打造 SPA 而生的框架，這點已滿足。

##### RWD (Responsive Web Design)

###### 實踐方法

- **Mobile-First Approach**: 設計時優先考慮行動裝置的佈局，再逐步擴展到平板和桌面。
- **Flexbox & Grid**: 使用 CSS Flexbox 和 Grid 進行佈局，它們能提供強大且靈活的響應式能力。
- **Tailwind CSS Breakpoints**: 善用 Tailwind CSS 提供的響應式斷點 (如 sm, md, lg, xl) 來調整不同螢幕尺寸下的樣式。
- **圖片優化**: 使用 `<picture>` 元素或 srcset 屬性為不同解析度的螢幕提供最適當的圖片。

##### UI/UX 規則

###### 一致性 (Consistency)

- 整個平台的視覺風格、元件行為、操作流程應保持一致。使用 PrimeVue 和 PrimeNG 有助於達成此目標。

###### 可用性 (Usability)

- **直觀性**: 使用者無需思考就能理解如何操作。
- **反饋**: 對於使用者的任何操作（點擊、輸入），系統都應給予即時且清晰的反饋（如 Loading 狀態、成功提示、錯誤訊息）。
- **容錯性**: 提供清晰的錯誤提示，並引導使用者如何修正。提供撤銷（Undo）或確認對話框等機制。

###### 性能 (Performance)

- **快速載入**: 做好程式碼分割（Code Splitting）和懶加載（Lazy Loading）。
- **流暢互動**: 避免複雜的 DOM 操作阻塞主線程，動畫應保持 60fps。

###### 無障礙設計 (Accessibility, a11y)

- 確保 UI 元件對螢幕閱讀器等輔助技術友好，例如為圖示按鈕提供 aria-label。

#### 4. 子專案技術棧

##### 子專案 (Vue 3)

- **前端框架**: Vue 3.x (建議使用 create-vue 或 Nuxt 3 初始化專案以獲得最佳實踐)
- **UI 元件庫**: PrimeVue (最新版本)
- **狀態管理**: Pinia (Vue 3 官方推薦)
- **路由**: Vue Router


### 後端 (Backend)

#### 5. 架構設計與 API

##### 設計理念

- **Clean Architecture / Hexagonal Architecture / Onion Architecture**: 這些架構的核心思想都是「依賴反轉」和「關注點分離」。

##### 實踐

- **Domain/Entities (核心層)**: 只包含最核心的業務邏輯和實體，不依賴任何外部框架。
- **Application/Use Cases (應用層)**: 編排業務流程，調用 Domain 層的邏輯。
- **Adapters/Infrastructure (基礎設施層)**: 實現具體的技術細節，如資料庫存取 (JPA)、Web API (Spring Web)、訊息佇列等。這一層依賴應用層。

##### API 規格

- **風格**: RESTful API
- **文件**: SpringDoc OpenAPI (Swagger)
- **描述**: 只需在 Spring Boot 專案中加入依賴，並搭配簡單的註解 (@Operation, @ApiResponse 等)，即可自動產生互動式的 API 文件。

#### 6. 技術框架與部署

##### 後端框架

Spring Boot 4.x (請注意,截至目前 Spring Boot 的最新版本為 4.x 系列。建議使用最新的穩定版本)

##### 部署模式

- **單體 (Monolith)**: 將所有功能打包成一個可執行的 JAR/WAR 檔案。
- **微服務 (Microservices)**: 將不同業務模組拆分成獨立的 Spring Boot 專案，每個服務都可以獨立開發、部署和擴展。

##### 運行環境

###### Container (容器)

- **技術**: Docker
- **實踐**: 為每個 Spring Boot 應用編寫 Dockerfile，將其打包成 Docker Image。
- **編排**: Kubernetes (K8s) 或 Docker Swarm，用於自動化部署、擴展和管理容器化應用。

###### VM (虛擬機)

- **說明**: 傳統的部署方式，直接在虛擬機上安裝 Java 環境並運行 JAR 檔案。

### 資料庫設計

- 資料庫設計模型: ER Model (Entity-Relationship Model)
- 工具: mermaid, draw.io, Lucidchart, MySQL Workbench 等工具可用於繪製 ERD。
- ORM (Object-Relational Mapping):
- 標準: JPA (Jakarta Persistence API)
- 實作: Hibernate (Spring Data JPA 預設的實作)。

資料庫支援:

- Spring Data JPA 透過設定不同的 DataSource 和 Dialect，可以輕鬆支援以下資料庫，無需修改業務程式碼：
  - Oracle
  - DB2
  - Microsoft SQL Server
  - PostgreSQL

### 平台通用功能

- Cache (快取):
  - 技術: Redis 或 Memcached。
  - Spring 整合: 使用 spring-boot-starter-data-redis 搭配 Spring Cache 抽象 (@Cacheable, @CacheEvict)，可以輕鬆實現聲明式快取。
- MQ (Message Queue):
  - 技術: RabbitMQ, Apache Kafka, AWS SQS。
  - Spring 整合: spring-boot-starter-amqp (for RabbitMQ) 或 spring-kafka。

- SFTP/FTPS:
  - Spring 整合: Spring Integration 框架提供了強大的 sftp-adapter 和 ftp-adapter，可以用來輪詢遠端伺服器檔案或將檔案上傳至遠端。

- **Batch (批次處理)**:
  - 技術: Spring Batch
  - 描述: 一個強大且成熟的批次處理框架，提供讀取-處理-寫入 (Reader-Processor-Writer) 的模式，並支援事務、重試、跳過等高級功能。

- **Teams/Line 整合**:
  - 技術: 透過 RESTful API 呼叫 Microsoft Teams 的 Incoming Webhook 或 Line 的 Messaging API 來發送通知。可以使用 Spring 的 RestTemplate 或 WebClient 來實現。

- **Log (日誌)**:
  - 框架: SLF4J + Logback/Log4j2 (Spring Boot 預設)
  - 集中化管理: ELK/EFK Stack (Elasticsearch, Logstash/Fluentd, Kibana)，將分散在各個服務的日誌統一收集、儲存和分析

- **Exception (異常處理)**:
  - 實踐: 使用 Spring 的 @ControllerAdvice 和 @ExceptionHandler 來建立全域的異常處理機制，將未捕獲的異常轉換為統一格式的 API 回應

- **多語系 (i18n)**:
  - 實踐: 使用 Spring 的 ResourceBundleMessageSource，將不同語言的訊息儲存在 .properties 檔案中，並根據請求的 Accept-Language header 回傳對應的語言訊息

- **監控 (Monitoring)**:
  - 技術: Spring Boot Actuator + Prometheus + Grafana
  - Actuator: 暴露應用程式的運行狀況、度量指標 (Metrics) 等端點
  - Prometheus: 定期抓取 Actuator 暴露的指標數據並儲存
  - Grafana: 將 Prometheus 的數據以圖形化的儀表板展示出來，方便監控與告警



### 開發與UT測試環境

#### 版本控制與專案建置

- **版本控制**: GitHub / GitLab 進行程式碼管理，使用 Git Flow 或 GitHub Flow 分支策略
- **建置工具**: Maven 3.x 進行專案建置，支援多模組架構
- **架構測試**: ArchUnit 測試各層間的依賴關係，確保架構完整性
- **單元測試**: JUnit 5 + Mockito 進行單元測試，目標覆蓋率 80%+
- **程式碼品質**: SonarQube 進行靜態程式碼分析與品質檢查

#### 開發工具配置

- **前端開發**: VS Code，搭配 Vue.js 相關擴展套件
- **後端開發**: IntelliJ IDEA Community 或 VS Code，搭配 Java、Spring Boot 相關擴展套件
- **跨平台支援**: 確保兩種 IDE 都能正常開發，提供相對應的專案配置檔

#### 容器化開發環境

- **容器工具**: Podman 進行容器化開發與測試，兼容 Docker 指令
- **編排工具**: Podman Compose 或 Docker Compose 管理多容器應用
- **開發環境**: 使用 Dev Containers 實現一致的開發環境
- **測試隔離**: 每個測試環境使用獨立容器，確保環境一致性

#### 統一監控與日誌系統

- **日誌收集**: 使用 Fluentd/Fluent Bit 或 Promtail 統一收集各容器日誌
- **日誌存储**: Elasticsearch 或 Loki 作為日誌存储後端
- **監控指標**: Prometheus 收集 CPU、記憶體、請求等系統指標
- **視覺化**: Grafana 提供統一的監控儀表板和告警機制
- **分散式追蹤**: TODO: 選擇 Jaeger 或 Zipkin 進行服務間追蹤
- **告警系統**: Alertmanager 配合 Grafana 實現智能告警

#### 跨IDE開發環境建置

- **專案結構**: 建立標準的專案目錄結構，支援多種IDE
- **配置檔案**: 提供 `.vscode/` 和 `.idea/` 配置檔案
- **建置腳本**: 統一的Maven建置腳本，與IDE無關
- **開發容器**: Dev Container配置，確保一致的開發環境

### SIT環境

#### 環境目的與特性

- **測試目標**: 驗證各子系統整合後的功能完整性、資料流正確性與系統穩定性
- **環境隔離**: 獨立於開發環境，模擬接近生產環境的配置
- **資料策略**: 使用脫敏的生產資料副本或專門準備的測試資料集
- **更新頻率**: 每日或每個 Sprint 結束時進行部署更新

#### 容器化部署

- **容器編排**: Kubernetes 或 Docker Swarm 管理多容器應用
- **映像管理**: 使用私有 Container Registry 存儲測試版本映像
- **版本控制**: 每個部署版本打上明確的標籤 (如 `sit-v1.2.3` 或 `sit-sprint-24`)
- **環境隔離**: 使用 Kubernetes Namespace 或獨立的容器網路隔離 SIT 環境
- **自動部署**: 透過 CI/CD Pipeline 自動化部署流程

#### 整合測試策略

- **API 整合測試**: 使用 REST Assured 或 Postman/Newman 進行 API 層級測試
- **端對端測試**: 前端使用 Cypress 或 Playwright 進行 E2E 測試
- **資料庫測試**: 驗證各服務間的資料一致性與交易完整性
- **效能測試**: 使用 JMeter 或 Gatling 進行基礎負載測試
- **測試自動化**: 整合至 CI/CD Pipeline，每次部署後自動執行測試套件

#### CI/CD 整合

- **持續整合**: GitHub Actions / GitLab CI / Jenkins 自動建置與測試
- **部署策略**: Blue-Green 或 Canary 部署，確保服務不中斷
- **回滾機制**: 保留前一版本映像，支援快速回滾
- **部署通知**: 透過 Teams/Line 發送部署狀態通知
- **測試報告**: 自動產生測試報告並整合至 SonarQube 與 Grafana

#### 環境配置管理

- **配置中心**: 使用 Spring Cloud Config Server 或 Kubernetes ConfigMap/Secret 管理配置
- **環境變數**: 透過環境變數注入 SIT 專屬配置（資料庫連線、API 端點等）
- **密鑰管理**: 使用 Vault 或 Kubernetes Secrets 安全存儲敏感資訊
- **多環境支援**: 支援多個 SIT 環境（SIT1, SIT2）供不同團隊並行測試

#### 監控與日誌系統

- **日誌收集**: Fluentd/Fluent Bit 收集所有容器日誌至 Elasticsearch/Loki
- **效能監控**: Prometheus 收集應用與基礎設施指標
- **視覺化儀表板**: Grafana 顯示即時監控資訊（CPU、記憶體、請求數、錯誤率）
- **分散式追蹤**: Jaeger 或 Zipkin 追蹤跨服務請求鏈路
- **告警機制**: Alertmanager 配置關鍵指標告警，異常時通知測試團隊
- **日誌保留**: 保留最近 30 天的日誌供問題排查

#### 資料庫環境

- **資料庫實例**: 獨立的資料庫實例，與開發環境完全隔離
- **資料同步**: 定期從生產環境同步並脫敏資料
- **資料備份**: 每日備份，支援快速還原至已知良好狀態
- **Schema 管理**: 使用 Flyway 或 Liquibase 進行資料庫版本控制
- **多資料庫支援**: 依測試需求配置 Oracle、PostgreSQL、SQL Server 等

#### 第三方服務整合

- **模擬服務**: 使用 WireMock 或 MockServer 模擬外部服務（SFTP、第三方 API）
- **訊息佇列**: 獨立的 RabbitMQ/Kafka 實例供測試使用
- **快取服務**: 獨立的 Redis 實例
- **通知測試**: Teams/Line 通知導向測試專用頻道

#### 測試資料管理

- **測試資料準備**: 使用腳本或工具（如 DbUnit）準備標準測試資料集
- **資料重置**: 提供快速重置測試資料的機制
- **資料產生器**: 使用 Faker 或類似工具產生大量測試資料
- **資料隔離**: 不同測試案例使用不同的資料範圍，避免互相干擾

#### 安全性測試

- **身份驗證測試**: 驗證 OAuth 2.0、JWT 等認證機制
- **授權測試**: 測試 RBAC（角色權限控制）的正確性
- **安全掃描**: 使用 OWASP ZAP 或 SonarQube 進行基礎安全漏洞掃描
- **API 安全**: 驗證 API 的輸入驗證、SQL 注入防護等

#### 環境維護與管理

- **健康檢查**: 定期檢查各服務健康狀態（Spring Boot Actuator Health Endpoint）
- **資源監控**: 監控容器資源使用情況，適時調整資源配置
- **定期清理**: 定期清理過期的映像、日誌、測試資料
- **問題追蹤**: 整合 JIRA 或類似工具，記錄並追蹤測試發現的問題
- **環境文件**: 維護 SIT 環境的架構圖、配置文件、存取資訊等文件



### 技術棧

技術棧總結表

| 類別 | 需求 | 建議技術/框架 |
|------|------|------------|
| 微前端架構 | 主框架 | Single-SPA 或 Module Federation |
|  | CSS | Tailwind CSS |
|  | 語言 | TypeScript |
| 前端子專案 1 | 框架 | Vue 3.x(最新穩定版) |
|  | UI 元件庫 | PrimeVue (最新穩定版) |
| 後端架構 | 設計模式 | Clean/Hexagonal/Onion Architecture |
|  | 部署架構 | OCP/GCP/azure/aws/VM |
|  | API | RESTful API + SpringDoc OpenAPI (Swagger) |
| 後端框架 | 主框架 | Spring Boot 4.x |
|  |語言 | java 25 |
|  | 部署環境 | Docker, Kubernetes, VM |
| 資料庫 | ORM | Spring Data JPA (Hibernate) |
|  | 支援資料庫 | Oracle, DB2, SQL Server, PostgreSQL |
| 通用功能 | 快取 | Redis + Spring Cache |
|  | 訊息佇列 | RabbitMQ / Kafka |
|  | 檔案傳輸 | Spring Integration (SFTP/FTPS) |
|  | 批次處理 | Spring Batch |
|  | 整合通知 | Teams/Line API (via WebClient) |
|  | 日誌/監控 | Logback, ELK Stack, Prometheus, Grafana |